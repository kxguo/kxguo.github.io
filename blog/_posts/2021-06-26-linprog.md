---
layout: post
title: 线性规划的单纯形法复习笔记和Python实现
tags: [Data Analysis]
image:
  path: /assets/img/blog/crab.png
description: >
  在销售管理部门工作时
  ，quest同学用excel的规划求解计算派单和认领的最优分配方案
  ，正好有机会复习相关原理并寻找python对应实现方法，整理如下
sitemap: false
---

快速定位：
[样例概述](#样例详解)
, [单纯形和变量替代法](#单纯形和变量替代法)
, [python实现](#python实现)

- Table of Contents
{:toc .large-only}

## 样例概述
### 问题简化
假设有如下限制条件：（没有确定业务逻辑）

- a. 每个派单电话平均需准备时间1分钟，认领需准备2分钟，总准备时长不超过22分钟
- b. 销售拨打精力为84分钟，平均一个派单消耗12分钟，平均一个认领消耗7分钟
- c. 派单和认领电话总量不超过80个

派单成单率0.5%，认领成单率1%，求最佳分配方案

### 解题思路
由于本例只有派单数和认领数两个变量，
可以用高中数学的图形接法，
找到限制条件对应的直线围出图形的定点求最优解。
但维度增加时就比较困难，
所以可以采用单纯形(simplex)方法，
找出超平面上符合条件的”顶点”，
引入稀疏变量求出：

设`x1`、`x2`分别为派单量、认领量，根据上述条件列出不等式：
- a. `x1 + 2·x2 <= 22` (引入变量`x3`)
- b. `12·x1 + 7·x2 <= 84` (引入变量`x4`)
- c. `x1 + x2 <= 80` (引入变量`x5`)
- 隐含条件: `x1 >= 0, x2 >= 0`

题目要求：求使`f = 0.5·x1 + 1·x2`最大的`x1`和`x2`

引入稀疏变量变为等式：
- a. `x1 + 2·x2 + x3 = 22`
- b. `12·x1 + 7·x2 + x4 = 84`
- c. `x1 + x2 + x5 = 80`

3个方程，5个变量，可知独立变量为3个，
先选`x3`、`x4`、`x5`为基变量，另其余变量为0，
可得一组解：\\
`x3 = 22, x4 = 84, x5 = 80`

## 单纯形和变量替代法
### 变量替代
参考[【运筹学】线性规划 单纯形法原理](https://blog.csdn.net/shulianghan/article/details/103348812)，
由于`f = 0.5·x1 + 1·x2`，对`x2`的依赖最多，因此选择`x2`为新的基变量，
被替换的基变量为原基变量`(x3、x4、x5)`中对`x2`变化最明显的变量，
求法为：

- 拆解线性规划条件的向量形式为：

$$
\begin{array}{lr}
maxZ=CX\\
s.t \left\{
             \begin{array}{lr}
			 \Sigma^{m}_{i=1}P_ix_i + \Sigma^{n}_{j=m+1}P_jx_j = b \\
             x_j\ge 0
             \end{array}
\right.
\end{array}
$$

- 原条件方程组对应系数矩阵的增广矩阵 (第`j`列构成列向量`Pj`)：

|`x1`|`x2`|`x3`|`x4`|`x5`||
|----|----|----|----|----|----|
|1|2|1|0|0|22|
|12|7|0|1|0|84|
|1|1|0|0|1|80|

- 其中`x2`的增广矩阵系数`p2 = 2·p3 + 7·p4 + 1·p5`，原基变量分别在`x2`增加到
22/2, 84/7, 80/1时将不满足隐藏条件，
因此将`x3`替换，用`x2`代替，
利用高斯消元法得到新的增广矩阵：

|`x1`|`x2`|`x3`|`x4`|`x5`||
|----|----|----|----|----|----|
|1/2|1|1/2|0|0|11|
|17/2|0|-7/2|1|0|7|
|1/2|0|-1/2|0|1|69|

得到顶点`A: x1 = 0, x2 = 11, f = 11`

- 测试是否为最优解，可以通过增广矩阵系数，对比`f`对其他变量的依赖是否小于`f`对当前基变量的依赖，
如果是则为唯一最优解，可以省略后续步骤。

### 寻找多重最优解
由于`x1`的增广矩阵系数`p1 = 1/2·p2 + 17/2·p4 + 1/2·p5`，
且`f`对`x1`的依赖（设为`c1`）为0.5，
`f`对当前基变量的依赖与对`x1`的依赖相同，为：

`c2·1/2 + c4·17/2 + c5·1/2 = c2·1/2 = 0.5 = c1`

因此`x1 = 0, x2 = 11`是最优解，但不是唯一最优解。
将`x1`继续替换当前基变量p4，可以得到最优解的另一个定点，对应增广矩阵:

|`x1`|`x2`|`x3`|`x4`|`x5`||
|----|----|----|----|----|----|
|0|1|12/17|-1/17|0|11-7/17|
|1|0|-7/17|2/17|0|14/17|
|0|0|-5/17|-1/17|1|69-7/17|

得到另一个顶点`B: x1 = 14/17, x2 = 11-7/17`

顶点A和B之间线段上的所有点都是最优解（**多重最优解**），他们决定的`f`都为11。

## Python实现
~~~python
from scipy import optimize as op
import numpy as np
#最优化默认寻找最小值，因此取负
f = np.array([-0.5,-1]) 
#条件a-c不等号左边系数，默认上限为B_ub，如果是下限则对A_ub取负
A_ub = np.array([[1,2] , [12,7] , [1,1]]) 
B_ub = np.array([22, 84, 80])
#采用单纯形方法
res = op.linprog(f, A_ub, B_ub, method = "simplex") 
print(res)
#-> fun: -11.0
#-> x: array([0.82352941, 10.58823529]) 即顶点B
#可以采用另外的最优化方法来得到另一个定点，如插值法(默认，不指定method)，或"revised simplex"
res = op.linprog(f, A_ub, B_ub, method = "revised simplex")
print(res)
# -> fun: -11.0
# -> x: array([0., 11.]) 即顶点A
#用插值法得到的一般为A和B之间的某个点，如[0.02434973, 10.98782472]
~~~
